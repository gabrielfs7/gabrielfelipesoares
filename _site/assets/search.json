

[
  
  
    
    
      {
        "title": "Object Modeling Principles",
        "excerpt": "There are 4 important Principles when modeling objects! They are the ADEG. Yes, as always I have invented a word to memorize them! Lets talk about them.\n\n",
        "content": "There are 4 important Principles when modeling objects! They are the ADEG. Yes, as always I have invented a word to memorize them! Lets talk about them.\n\n\n\n&lt;/small&gt;\nWIP: This article is a working in progress. There could be some errors. I will also add some images to help the understanding :)\n&lt;/small&gt;\n\nAn brief history review, first:\n\n1960’s\n\nDuring the 1960’s there was the Imperative Paradigm where programs basically were composed of routines that interact with other small routines and shared the same Global Variables. The processment were really expensive and the focus were most about hardware capacity than in the solution itself.\n\nThis was the age of Cobol, Fortran and such imperative programing languages.\n\n1970’s\n\nIn this period of time we had a huge avance and now developers could use local variables without being worried about messup the system by trusting in shared global variables.\n\nAlso the first scratch of what would become an “object” in the future was created, the Abstract Type or structs.\n\nIn this time, programs started beign splited in multiple files and C header file was introduced.\n\nThis was the age of Algol, C, Pascal and other programing languages that allowed developers to use Abstract Types and local variables.\n\n1980’s to now\n\nFinally the concept of object was applyed to program languages and became possible split the problem and classes and methods and became easier to use business language in the code.\n\nAs examples of languages we can mention Java, C++, C# among many others object oriented languages.\n\n1. Abstraction\n\nThe abstraction principle consists in “abstract” the general business needs into classes and methods without concert too much about details.\n\nAt this point the idea is not mature yet and the goal is to translate the initial problem to a high level code base.\n\n2. Decomposition\n\nAs we start diging we find more business needes we did not think before the problem becomes bigger and bigger.\n\nInstead of get crazy, we start breaking down (or decomposing) the previous classes in more and specialized ones. We create abstractios, interfaces, new entities are discovered and so on.\n\nThe goal here is to go deep in the details by decomposing the big problem in smaller and cotrolled solutons.\n\nTypes of Decomposition relations\n\nAssociation\n\n\n  Relationship is optional\n  Associated classes are completely independent.\n\n\nAggregatione\n\n\n  Weak has-a relationship.\n  One object does not need to have the other to exist.\n\n\nComposition\n\n\n  Strong has-a relationship\n  Associated classes are completely dependent. Example, an object Human always has an object Brain associated, otherwise it cannot exist.\n\n\n3. Encapsulation\n\nWhen decomposing the classes we start creating new methods and attributes that concern only for those classes. It is time to use inheritance, abstraction and access modifiers to to restrict for them.\n\nWe have some conventions for this like “getters” and “setter” methods, besides today they are controversial in some cases after the surge of Object Calisthenics.\n\n4. Generalization\n\nWhen a class inherits behavior or interface from a superior (super) class we call it Generalization. It can happen in two ways:\n\nBy Abstraction\n\nAn abstract class (cannot be instantiated) has some methods (behaviour) or propeties that can be shared with the chield classes.\n\nBy Interface\n\nAn interface (or Contract) is created, so the classes that implement this interface can entirely manange the internal implementation of the interface’s expected behaviour.\n\nThen comes in place the Polimorthism.\n",
        "url": "/software-architecture/2019/09/06/object-modeling-principles/"
      },
    
      {
        "title": "Software Architecture Design Principles",
        "excerpt": "There are 4 important Design Principles to guide architects when modeling software. They are the CoSICi principles. I have invented this word to help me out memorize them! So far it is working and I would like to share it!\n\n",
        "content": "There are 4 important Design Principles to guide architects when modeling software. They are the CoSICi principles. I have invented this word to help me out memorize them! So far it is working and I would like to share it!\n\n\n\n\nWIP: This article is a working in progress. There could be some errors. I will also add some images to help the understanding :)\n\n\n1. (Co) Coupling &amp; Cohesion\n\nBesides the different names, Coupling and Cohesion are intimally related, cause \nboth concern about software complexity.\n\nBefore explain each one, lets first define what is considered a module within this scope.\n\nModule can be a:\n\n\n  Software Component.\n  A Class\n  A Method of a Class\n  A Function\n\n\nCoupling\n\nCoupling represents the level of complexity involving multiple modules.\n\nCohesion\n\nCohesion represents the level of complexity inside a single module.\n\nAnd how to evaluate complexity?\n\nTo evaluate complexity we consider 3 important aspects: Degree, Easy, Flexibility:\n\nDegree\n\nThe Degree relates to the number of connections between modules. Are they tighlty coupled\nto other modules?\n\nEasy\n\nThe Easy relates to how obvious are these connections. Do they follow a standard with meaningfull names and purspose?\n\nFlexibility\n\nCan the module be used by others without refactoring? Does it have a generic interface that can be easily used by other modules without colateral effect?\n\n2. (S) Separation of Concerns\n\nA component, service, class or method should have a single, clear and meaningfull purpose.\n\nHere comes handy the usage of SOLID principles, specially the (S) Single Responsibility.\n\nTips:\n\n\n  Relay on interfaces instead of concrete classes. When creating inerfaces, you can better define the classes responsibility.\n  Use propeties and methods access modifiers to restrict access.\n  Expose only necessary information on the APIs.\n  Avoid to appropriate data from other Domains to your application. Respect the Softwares Boundaries\n\n\n3. (I) Information Hiding\n\nA module should only expose necessary information for other components. This means that a module\nshould only know what he needs to know to fill his purpose and also only expose information that is necessary for other modules purposes.\n\nBe aware to use encapsulation and guard methods (i.e setter / constructors / getters) to receive and expose information in the correct ways.\n\n4. (CI) Conceptual Integrity\n\nI like to say the Conceptual Integrity is as good as the the alignment of business knowlege, technical expertise and process compliance that the individuals have.\n\nTips:\n\n\n  Follow a code standard.\n  Traininig and adjust knowledge levels of the individuals to be as similar as possible.\n  Do Code Reviews to reinforce the standards are being applyed.\n  Have a weel defined, accepted and execute SDLC (Software Development Life Cycle). Does not matter if you use Scrum, Kanban, whaterfall or whatever. If it is accepted and used by the individuals, this is what matters.\n\n\n",
        "url": "/software-architecture/2019/09/07/software-architecture-design-principles/"
      },
    
      {
        "title": "Model Checking, What it is and why to use it",
        "excerpt": "After finish the implementation of the so (or sometimes not) desired system, how do you know that it is (and behave) exactly as expected? Requirements change, people can forget, communications problems ocurr even in the best companies.\n\n",
        "content": "After finish the implementation of the so (or sometimes not) desired system, how do you know that it is (and behave) exactly as expected? Requirements change, people can forget, communications problems ocurr even in the best companies.\n\n\n\n\nWIP: This article is a working in progress. There could be some errors. I will also add some images to help the understanding :)\n\n\nWhat is Model Checking?\n\nModel checking is the technique to check if the behaviour of the State Model of your system work as expected and notify any violation.\n\nWhat is a State Model?\n\nThe State Model is an abstract State Machine that can be in one or various states, so the Model checker can verify if the state mode conforms with expected behavior and properties.\n\nModeling phase\n\nDescribe all possible states and properties to be checked against your system.\n\nYou can use Unit Tests, BDD, etc. There are many tools out there to help you.\n\nRunning phase\n\nRun the necessary test of your State Machine against the expectations described on the previous phase.\n\nAnalysis phase\n\nCheck the results of the previous phase. If the State Model does not conforms with certain behaviour or property we ha a Violation AKA Counterexamples.\n\nThe outuput of a Counterexample must show you exaclty how to reproduce the violation, so you system can be fixed.\n\nWhen should I do a Model checking?\n\nAlways after implementation and before production deploy. It is untrue that a Software can be perfect during the planning or modeling phases. The beauty of software is that it can change many times before and after its implementation. Business needs flexiblity, but we (developers) need to make sure it will work as expected after all those changes.\n",
        "url": "/software-architecture/2019/09/08/software-architecture-model-checking/"
      },
    
  
  
  
  {
    "title": "Categories",
    "excerpt": "Select a category\n",
    "content": "\n",
    "url": "/categories/"
  },
  
  {
    "title": "Gabriel's Blog",
    "excerpt": "…\n",
    "content": "Hello,\n\nMy name is Gabriel and I am a Software Developer based in Luxembourg. Here is a place to share my thoughts and what I have learned in my professional life.\n",
    "url": "/"
  },
  
  {
    "title": "Search",
    "excerpt": "Search for a page or post you’re looking for\n",
    "content": "{% include site-search.html %}\n",
    "url": "/search/"
  }
  
]

