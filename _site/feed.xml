<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-GB"><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="http://0.0.0.0:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://0.0.0.0:4000/" rel="alternate" type="text/html" hreflang="en-GB" /><updated>2019-09-08T14:40:03+01:00</updated><id>http://0.0.0.0:4000/feed.xml</id><title type="html">Gabrielâ€™s Blog</title><subtitle>Sharing my thoughts about IT related subjects</subtitle><author><name>Gabriel Felipe Soares</name></author><entry><title type="html">Software Architecture Design Principles</title><link href="http://0.0.0.0:4000/software%20architecture/2019/09/08/software-architecture-design-principles/" rel="alternate" type="text/html" title="Software Architecture Design Principles" /><published>2019-09-08T00:00:00+01:00</published><updated>2019-09-08T00:00:00+01:00</updated><id>http://0.0.0.0:4000/software%20architecture/2019/09/08/software-architecture-design-principles</id><content type="html" xml:base="http://0.0.0.0:4000/software%20architecture/2019/09/08/software-architecture-design-principles/">&lt;p&gt;&lt;em&gt;WIP:&lt;/em&gt; This article is a working in progress. There could be some errors :)&lt;/p&gt;

&lt;p&gt;There are 4 important &lt;em&gt;Design Principles&lt;/em&gt; to guide architects when modeling software. They are the &lt;em&gt;CoSICi&lt;/em&gt; principles. I have invented this word to help me out memorize them! So far it is working and I would like to share it!&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&quot;1-co-coupling--cohesion&quot;&gt;1. (Co) Coupling &amp;amp; Cohesion&lt;/h2&gt;

&lt;p&gt;Besides the different names, Coupling and Cohesion are intimally related, cause 
both concern about &lt;em&gt;software complexity&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Before explain each one, lets first define what is considered a &lt;em&gt;module&lt;/em&gt; within this scope.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Module&lt;/em&gt; can be a:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Software Component.&lt;/li&gt;
  &lt;li&gt;A Class&lt;/li&gt;
  &lt;li&gt;A Method of a Class&lt;/li&gt;
  &lt;li&gt;A Function&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;coupling&quot;&gt;Coupling&lt;/h3&gt;

&lt;p&gt;Coupling represents the level of complexity involving multiple modules.&lt;/p&gt;

&lt;h3 id=&quot;cohesion&quot;&gt;Cohesion&lt;/h3&gt;

&lt;p&gt;Cohesion represents the level of complexity inside a single module.&lt;/p&gt;

&lt;h3 id=&quot;and-how-to-evaluate-complexity&quot;&gt;And how to evaluate complexity?&lt;/h3&gt;

&lt;p&gt;To evaluate complexity we consider 3 important aspects: Degree, Easy, Flexibility:&lt;/p&gt;

&lt;h4 id=&quot;degree&quot;&gt;Degree&lt;/h4&gt;

&lt;p&gt;The Degree relates to the number of connections between modules. Are they tighlty coupled
to other modules?&lt;/p&gt;

&lt;h4 id=&quot;easy&quot;&gt;Easy&lt;/h4&gt;

&lt;p&gt;The Easy relates to how obvious are these connections. Do they follow a standard with meaningfull names and purspose?&lt;/p&gt;

&lt;h4 id=&quot;flexibility&quot;&gt;Flexibility&lt;/h4&gt;

&lt;p&gt;Can the module be used by others without refactoring? Does it have a generic interface that can be easily used by other modules without colateral effect?&lt;/p&gt;

&lt;h2 id=&quot;2-s-separation-of-concerns&quot;&gt;2. (S) Separation of Concerns&lt;/h2&gt;

&lt;p&gt;A component, service, class or method should have a single, clear and meaningfull purpose.&lt;/p&gt;

&lt;p&gt;Here comes handy the usage of SOLID principles, specially the (S) Single Responsibility.&lt;/p&gt;

&lt;p&gt;Tips:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Relay on interfaces instead of concrete classes. When creating inerfaces, you can better define the classes responsibility.&lt;/li&gt;
  &lt;li&gt;Use propeties and methods access modifiers to restrict access.&lt;/li&gt;
  &lt;li&gt;Expose only necessary information on the APIs.&lt;/li&gt;
  &lt;li&gt;Avoid to appropriate data from other &lt;em&gt;Domains&lt;/em&gt; to your application. Respect the &lt;em&gt;Softwares Boundaries&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-i-information-hiding&quot;&gt;3. (I) Information Hiding&lt;/h2&gt;

&lt;p&gt;A module should only expose necessary information for other components. This means that a module
should only know what he needs to know to fill his purpose and also only expose information that is necessary for other modules purposes.&lt;/p&gt;

&lt;p&gt;Be aware to use &lt;em&gt;encapsulation&lt;/em&gt; and guard methods (i.e setter / constructors / getters) to receive and expose information in the correct ways.&lt;/p&gt;

&lt;h2 id=&quot;4-ci-conceptual-integrity&quot;&gt;4. (CI) Conceptual Integrity&lt;/h2&gt;

&lt;p&gt;I like to say the Conceptual Integrity is as good as the the alignment of business knowlege, technical expertise and process compliance that the individuals have.&lt;/p&gt;

&lt;p&gt;Tips:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Follow a code standard.&lt;/li&gt;
  &lt;li&gt;Traininig and adjust knowledge levels of the individuals to be as similar as possible.&lt;/li&gt;
  &lt;li&gt;Do Code Reviews to reinforce the standards are being applyed.&lt;/li&gt;
  &lt;li&gt;Have a weel defined, accepted and execute SDLC (Software Development Life Cycle). Does not matter if you use Scrum, Kanban, whaterfall or whatever. If it is accepted and used by the individuals, this is what matters.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Gabriel Felipe Soares</name></author><summary type="html">WIP: This article is a working in progress. There could be some errors :) There are 4 important Design Principles to guide architects when modeling software. They are the CoSICi principles. I have invented this word to help me out memorize them! So far it is working and I would like to share it!</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://0.0.0.0:4000/assets/default-social-image.png" /></entry></feed>