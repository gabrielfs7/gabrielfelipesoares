<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-GB"><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="http://0.0.0.0:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://0.0.0.0:4000/" rel="alternate" type="text/html" hreflang="en-GB" /><updated>2019-09-08T15:49:34+01:00</updated><id>http://0.0.0.0:4000/feed.xml</id><title type="html">Gabriel’s Blog</title><subtitle>Sharing my thoughts about IT related subjects</subtitle><author><name>Gabriel Felipe Soares</name></author><entry><title type="html">Software Architecture Design Principles</title><link href="http://0.0.0.0:4000/software-architecture/2019/09/08/software-architecture-design-principles/" rel="alternate" type="text/html" title="Software Architecture Design Principles" /><published>2019-09-08T00:00:00+01:00</published><updated>2019-09-08T00:00:00+01:00</updated><id>http://0.0.0.0:4000/software-architecture/2019/09/08/software-architecture-design-principles</id><content type="html" xml:base="http://0.0.0.0:4000/software-architecture/2019/09/08/software-architecture-design-principles/">&lt;p&gt;There are 4 important &lt;em&gt;Design Principles&lt;/em&gt; to guide architects when modeling software. They are the &lt;strong&gt;CoSICi&lt;/strong&gt; principles. I have invented this word to help me out memorize them! So far it is working and I would like to share it!&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;&lt;small&gt;
&lt;em&gt;WIP:&lt;/em&gt; This article is a working in progress. There could be some errors. I will also add some images to help the understanding :)
&lt;/small&gt;&lt;/p&gt;

&lt;h2 id=&quot;1-co-coupling--cohesion&quot;&gt;1. (Co) Coupling &amp;amp; Cohesion&lt;/h2&gt;

&lt;p&gt;Besides the different names, Coupling and Cohesion are intimally related, cause 
both concern about &lt;em&gt;software complexity&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Before explain each one, lets first define what is considered a &lt;em&gt;module&lt;/em&gt; within this scope.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Module&lt;/em&gt; can be a:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Software Component.&lt;/li&gt;
  &lt;li&gt;A Class&lt;/li&gt;
  &lt;li&gt;A Method of a Class&lt;/li&gt;
  &lt;li&gt;A Function&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;coupling&quot;&gt;Coupling&lt;/h3&gt;

&lt;p&gt;Coupling represents the level of complexity involving multiple modules.&lt;/p&gt;

&lt;h3 id=&quot;cohesion&quot;&gt;Cohesion&lt;/h3&gt;

&lt;p&gt;Cohesion represents the level of complexity inside a single module.&lt;/p&gt;

&lt;h3 id=&quot;and-how-to-evaluate-complexity&quot;&gt;And how to evaluate complexity?&lt;/h3&gt;

&lt;p&gt;To evaluate complexity we consider 3 important aspects: Degree, Easy, Flexibility:&lt;/p&gt;

&lt;h4 id=&quot;degree&quot;&gt;Degree&lt;/h4&gt;

&lt;p&gt;The Degree relates to the number of connections between modules. Are they tighlty coupled
to other modules?&lt;/p&gt;

&lt;h4 id=&quot;easy&quot;&gt;Easy&lt;/h4&gt;

&lt;p&gt;The Easy relates to how obvious are these connections. Do they follow a standard with meaningfull names and purspose?&lt;/p&gt;

&lt;h4 id=&quot;flexibility&quot;&gt;Flexibility&lt;/h4&gt;

&lt;p&gt;Can the module be used by others without refactoring? Does it have a generic interface that can be easily used by other modules without colateral effect?&lt;/p&gt;

&lt;h2 id=&quot;2-s-separation-of-concerns&quot;&gt;2. (S) Separation of Concerns&lt;/h2&gt;

&lt;p&gt;A component, service, class or method should have a single, clear and meaningfull purpose.&lt;/p&gt;

&lt;p&gt;Here comes handy the usage of SOLID principles, specially the (S) Single Responsibility.&lt;/p&gt;

&lt;p&gt;Tips:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Relay on interfaces instead of concrete classes. When creating inerfaces, you can better define the classes responsibility.&lt;/li&gt;
  &lt;li&gt;Use propeties and methods access modifiers to restrict access.&lt;/li&gt;
  &lt;li&gt;Expose only necessary information on the APIs.&lt;/li&gt;
  &lt;li&gt;Avoid to appropriate data from other &lt;em&gt;Domains&lt;/em&gt; to your application. Respect the &lt;em&gt;Softwares Boundaries&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-i-information-hiding&quot;&gt;3. (I) Information Hiding&lt;/h2&gt;

&lt;p&gt;A module should only expose necessary information for other components. This means that a module
should only know what he needs to know to fill his purpose and also only expose information that is necessary for other modules purposes.&lt;/p&gt;

&lt;p&gt;Be aware to use &lt;em&gt;encapsulation&lt;/em&gt; and guard methods (i.e setter / constructors / getters) to receive and expose information in the correct ways.&lt;/p&gt;

&lt;h2 id=&quot;4-ci-conceptual-integrity&quot;&gt;4. (CI) Conceptual Integrity&lt;/h2&gt;

&lt;p&gt;I like to say the Conceptual Integrity is as good as the the alignment of business knowlege, technical expertise and process compliance that the individuals have.&lt;/p&gt;

&lt;p&gt;Tips:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Follow a code standard.&lt;/li&gt;
  &lt;li&gt;Traininig and adjust knowledge levels of the individuals to be as similar as possible.&lt;/li&gt;
  &lt;li&gt;Do Code Reviews to reinforce the standards are being applyed.&lt;/li&gt;
  &lt;li&gt;Have a weel defined, accepted and execute SDLC (Software Development Life Cycle). Does not matter if you use Scrum, Kanban, whaterfall or whatever. If it is accepted and used by the individuals, this is what matters.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Gabriel Felipe Soares</name></author><summary type="html">There are 4 important Design Principles to guide architects when modeling software. They are the CoSICi principles. I have invented this word to help me out memorize them! So far it is working and I would like to share it!</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://0.0.0.0:4000/assets/default-social-image.png" /></entry><entry><title type="html">Object Modeling Principles</title><link href="http://0.0.0.0:4000/software-architecture/2019/09/07/object-modeling-principles/" rel="alternate" type="text/html" title="Object Modeling Principles" /><published>2019-09-07T00:00:00+01:00</published><updated>2019-09-07T00:00:00+01:00</updated><id>http://0.0.0.0:4000/software-architecture/2019/09/07/object-modeling-principles</id><content type="html" xml:base="http://0.0.0.0:4000/software-architecture/2019/09/07/object-modeling-principles/">&lt;p&gt;There are 4 important &lt;em&gt;Principles&lt;/em&gt; when modeling objects! They are the &lt;strong&gt;ADEG&lt;/strong&gt;. Yes, as always I have invented a word to memorize them! Lets talk about them.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;&amp;lt;/small&amp;gt;
&lt;em&gt;WIP:&lt;/em&gt; This article is a working in progress. There could be some errors. I will also add some images to help the understanding :)
&amp;lt;/small&amp;gt;&lt;/p&gt;

&lt;p&gt;An brief history review, first:&lt;/p&gt;

&lt;h1 id=&quot;1960s&quot;&gt;1960’s&lt;/h1&gt;

&lt;p&gt;During the 1960’s there was the &lt;strong&gt;Imperative Paradigm&lt;/strong&gt; where programs basically were composed of routines that interact with other small routines and shared the same &lt;strong&gt;Global Variables&lt;/strong&gt;. The processment were really expensive and the focus were most about hardware capacity than in the solution itself.&lt;/p&gt;

&lt;p&gt;This was the age of Cobol, Fortran and such imperative programing languages.&lt;/p&gt;

&lt;h1 id=&quot;1970s&quot;&gt;1970’s&lt;/h1&gt;

&lt;p&gt;In this period of time we had a huge avance and now developers could use &lt;strong&gt;local variables&lt;/strong&gt; without being worried about messup the system by trusting in shared global variables.&lt;/p&gt;

&lt;p&gt;Also the first scratch of what would become an “object” in the future was created, the &lt;strong&gt;Abstract Type&lt;/strong&gt; or structs.&lt;/p&gt;

&lt;p&gt;In this time, programs started beign splited in multiple files and C header file was introduced.&lt;/p&gt;

&lt;p&gt;This was the age of Algol, C, Pascal and other programing languages that allowed developers to use Abstract Types and local variables.&lt;/p&gt;

&lt;h1 id=&quot;1980s-to-now&quot;&gt;1980’s to now&lt;/h1&gt;

&lt;p&gt;Finally the concept of object was applyed to program languages and became possible split the problem and classes and methods and became easier to use business language in the code.&lt;/p&gt;

&lt;p&gt;As examples of languages we can mention Java, C++, C# among many others object oriented languages.&lt;/p&gt;

&lt;h2 id=&quot;1-abstraction&quot;&gt;1. Abstraction&lt;/h2&gt;

&lt;p&gt;The abstraction principle consists in “abstract” the general business needs into classes and methods without concert too much about details.&lt;/p&gt;

&lt;p&gt;At this point the idea is not mature yet and the goal is to translate the initial problem to a high level code base.&lt;/p&gt;

&lt;h2 id=&quot;2-decomposition&quot;&gt;2. Decomposition&lt;/h2&gt;

&lt;p&gt;As we start diging we find more business needes we did not think before the problem becomes bigger and bigger.&lt;/p&gt;

&lt;p&gt;Instead of get crazy, we start breaking down (or decomposing) the previous classes in more and specialized ones. We create abstractios, interfaces, new entities are discovered and so on.&lt;/p&gt;

&lt;p&gt;The goal here is to go deep in the details by decomposing the big problem in smaller and cotrolled solutons.&lt;/p&gt;

&lt;h3 id=&quot;types-of-decomposition-relations&quot;&gt;Types of Decomposition relations&lt;/h3&gt;

&lt;h4 id=&quot;association&quot;&gt;Association&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Relationship is optional&lt;/li&gt;
  &lt;li&gt;Associated classes are completely independent.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;aggregatione&quot;&gt;Aggregatione&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Weak &lt;strong&gt;has-a&lt;/strong&gt; relationship.&lt;/li&gt;
  &lt;li&gt;One object does not need to have the other to exist.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;composition&quot;&gt;Composition&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Strong &lt;strong&gt;has-a&lt;/strong&gt; relationship&lt;/li&gt;
  &lt;li&gt;Associated classes are &lt;strong&gt;completely dependent&lt;/strong&gt;. Example, an object &lt;strong&gt;Human&lt;/strong&gt; always has an object &lt;strong&gt;Brain&lt;/strong&gt; associated, otherwise it cannot exist.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-encapsulation&quot;&gt;3. Encapsulation&lt;/h2&gt;

&lt;p&gt;When decomposing the classes we start creating new methods and attributes that concern only for those classes. It is time to use inheritance, abstraction and access modifiers to to restrict for them.&lt;/p&gt;

&lt;p&gt;We have some conventions for this like “getters” and “setter” methods, besides today they are controversial in some cases after the surge of Object Calisthenics.&lt;/p&gt;

&lt;h2 id=&quot;4-generalization&quot;&gt;4. Generalization&lt;/h2&gt;

&lt;p&gt;When a class inherits behavior or interface from a superior (super) class we call it &lt;strong&gt;Generalization&lt;/strong&gt;. It can happen in two ways:&lt;/p&gt;

&lt;h3 id=&quot;by-abstraction&quot;&gt;By Abstraction&lt;/h3&gt;

&lt;p&gt;An abstract class (cannot be instantiated) has some methods (behaviour) or propeties that can be shared with the &lt;strong&gt;chield classes&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&quot;by-interface&quot;&gt;By Interface&lt;/h3&gt;

&lt;p&gt;An interface (or Contract) is created, so the classes that implement this interface can entirely manange the internal implementation of the interface’s expected behaviour.&lt;/p&gt;

&lt;p&gt;Then comes in place the &lt;strong&gt;Polimorthism&lt;/strong&gt;.&lt;/p&gt;</content><author><name>Gabriel Felipe Soares</name></author><summary type="html">There are 4 important Principles when modeling objects! They are the ADEG. Yes, as always I have invented a word to memorize them! Lets talk about them.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://0.0.0.0:4000/assets/default-social-image.png" /></entry></feed>