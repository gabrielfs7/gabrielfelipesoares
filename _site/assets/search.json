

[
  
  
    
    
      {
        "title": "Object Modeling Principles",
        "excerpt": "There are 4 important Principles when modeling objects! They are the ADEG. Yes, as always I have invented a word to memorize them! Lets talk about them.\n\n",
        "content": "There are 4 important Principles when modeling objects! They are the ADEG. Yes, as always I have invented a word to memorize them! Lets talk about them.\n\n\n\n\nWIP: This article is a working in progress. There could be some errors. I will also add some images to help the understanding :)\n\n\nAn brief history review, first:\n\n1960’s\n\nDuring the 1960’s there was the Imperative Paradigm where programs basically were composed of routines that interact with other small routines and shared the same Global Variables. The processing were really expensive and the focus were most about hardware capacity than in the solution itself.\n\nThis was the age of Cobol, Fortran and others Imperative Programing languages.\n\n1970’s\n\nIn this period of time we had a huge progress and now developers could use local variables without being worried about mess up the system by trusting in shared global variables.\n\nAlso the first scratch of what would become an “object” in the future was created, the Abstract Type or Structs.\n\nIn this time, programs started being divided in multiple files and C header file was introduced.\n\nThis was the age of Algol, C, Pascal and other programing languages that allowed developers to use Abstract Types and local variables.\n\nC Struct example:\n\nstruct Person\n{\n    char name[50];\n    int citNo;\n    float salary;\n};\n\n\n1980’s to now\n\nFinally the concept of object was applied to program languages and became possible split the problem and classes and methods and became easier to use business language in the code.\n\nAs examples of languages we can mention Java, C++, C# among many others object oriented languages.\n\nJava class example\n\n\npublic class Car\n{\n    private String brand;\n    private String model;\n\n    public Car(String brand, String model)\n    {\n        brand = brand;\n        model = model;\n    }\n\n    \n    public String getModel()\n    {\n        return model;\n    }\n\n    public void setModel(String model)\n    {\n        model = model;\n    }\n\n    public String getBrand()\n    {\n        return brand;\n    }\n\n    public void setBrand(String brand)\n    {\n        brand = brand;\n    }\n}\n\n\n1. Abstraction\n\nThe abstraction principle consists in “abstract” the general business needs into classes and methods without concert too much about details.\n\nAt this point the idea is not mature yet and the goal is to translate the initial problem to a high level code base.\n\n2. Decomposition\n\nAs we start digging we find more business needs we did not think before the problem becomes bigger and bigger.\n\nInstead of get crazy, we start breaking down (or decomposing) the previous classes in more and specialized ones. We create abstractions, interfaces, new entities are discovered and so on.\n\nThe goal here is to go deep in the details by decomposing the big problem in smaller and controlled solutions.\n\nTypes of Decomposition relations\n\nAssociation\n\n\n  Relationship is optional\n  Associated classes are completely independent.\n\n\n\n  \n  UML class diagram Association example\n\n\nAggregation\n\n\n  Weak has-a relationship.\n  One object does not need to have the other to exist.\n\n\n\n  \n  UML class diagram aggregation example\n\n\nComposition\n\n\n  Strong has-a relationship\n  Associated classes are completely dependent. Example, an object Human always has an object Brain associated, otherwise it cannot exist.\n\n\n\n  \n  UML class diagram composition example\n\n\n3. Encapsulation\n\nWhen decomposing the classes we start creating new methods and attributes that concern only for those classes. It is time to use inheritance, abstraction and access modifiers to to restrict for them.\n\nWe have some conventions for this like “getters” and “setter” methods, besides today they are controversial in some cases after the surge of Object Calisthenics.\n\n4. Generalization\n\nWhen a class inherits behavior or interface from a superior (super) class we call it Generalization. It can happen in two ways:\n\n\n  \n  UML class diagram Generalization example\n\n\nBy Abstraction\n\nAn abstract class (cannot be instantiated) has some methods (behavior) or properties that can be shared with the child classes.\n\nBy Interface\n\nAn interface (or Contract) is created, so the classes that implement this interface can entirely manage the internal implementation of the interface’s expected behavior.\n\nThen comes in place the Polymorphism.\n",
        "url": "/software-architecture/2019/09/06/object-modeling-principles/"
      },
    
      {
        "title": "Software Architecture Design Principles",
        "excerpt": "There are 4 important Design Principles to guide architects when modeling software. They are the CoSICi principles. I have invented this word to help me out memorize them! So far it is working and I would like to share it!\n\n",
        "content": "There are 4 important Design Principles to guide architects when modeling software. They are the CoSICi principles. I have invented this word to help me out memorize them! So far it is working and I would like to share it!\n\n\n\n\nWIP: This article is a working in progress. There could be some errors. I will also add some images to help the understanding :)\n\n\n1. (Co) Coupling &amp; Cohesion\n\nBesides the different names, Coupling and Cohesion are intimately related, cause \nboth concern about software complexity.\n\nBefore explain each one, lets first define what is considered a module within this scope.\n\nModule can be a:\n\n\n  Software Component.\n  A Class\n  A Method of a Class\n  A Function\n\n\nCoupling\n\nCoupling represents the level of complexity involving multiple modules.\n\nCohesion\n\nCohesion represents the level of complexity inside a single module.\n\nAnd how to evaluate complexity?\n\nTo evaluate complexity we consider 3 important aspects: Degree, Easy, Flexibility:\n\nDegree\n\nThe Degree relates to the number of connections between modules. Are they tightly coupled\nto other modules?\n\nEasy\n\nThe Easy relates to how obvious are these connections. Do they follow a standard with meaningful names and purpose?\n\nFlexibility\n\nCan the module be used by others without refactoring? Does it have a generic interface that can be easily used by other modules without collateral effect?\n\n2. (S) Separation of Concerns\n\nA component, service, class or method should have a single, clear and meaningful purpose.\n\nHere comes handy the usage of SOLID principles, specially the (S) Single Responsibility.\n\nTips:\n\n\n  Relay on interfaces instead of concrete classes. When creating interfaces, you can better define the classes responsibility.\n  Use properties and methods access modifiers to restrict access.\n  Expose only necessary information on the APIs.\n  Avoid to appropriate data from other Domains to your application. Respect the Softwares Boundaries\n\n\n3. (I) Information Hiding\n\nA module should only expose necessary information for other components. This means that a module\nshould only know what he needs to know to fill his purpose and also only expose information that is necessary for other modules purposes.\n\nBe aware to use encapsulation and guard methods (i.e setter / constructors / getters) to receive and expose information in the correct ways.\n\n4. (CI) Conceptual Integrity\n\nI like to say the Conceptual Integrity is as good as the the alignment of business knowledge, technical expertise and process compliance that the individuals have.\n\nTips:\n\n\n  Follow a code standard.\n  Training and adjust knowledge levels of the individuals to be as similar as possible.\n  Do Code Reviews to reinforce the standards are being applied.\n  Have a well defined, accepted and execute SDLC (Software Development Life Cycle). Does not matter if you use Scrum, Kanban, water fall or whatever. If it is accepted and used by the individuals, this is what matters.\n\n\n",
        "url": "/software-architecture/2019/09/07/software-architecture-design-principles/"
      },
    
      {
        "title": "Model Checking, What it is and why to use it",
        "excerpt": "After finish the implementation of the so (or sometimes not) desired system, how do you know that it is (and behave) exactly as expected? Requirements change, people can forget, communications problems occur even in the best companies.\n\n",
        "content": "After finish the implementation of the so (or sometimes not) desired system, how do you know that it is (and behave) exactly as expected? Requirements change, people can forget, communications problems occur even in the best companies.\n\n\n\n\nWIP: This article is a working in progress. There could be some errors. I will also add some images to help the understanding :)\n\n\nWhat is Model Checking?\n\nModel checking is the technique to check if the behavior of the State Model of your system work as expected and notify any violation.\n\nWhat is a State Model?\n\nThe State Model is an abstract State Machine that can be in one or various states, so the Model checker can verify if the state mode conforms with expected behavior and properties.\n\nModeling phase\n\nDescribe all possible states and properties to be checked against your system.\n\nYou can use Unit Tests, BDD, etc. There are many tools out there to help you.\n\nRunning phase\n\nRun the necessary test of your State Machine against the expectations described on the previous phase.\n\nAnalysis phase\n\nCheck the results of the previous phase. If the State Model does not conforms with certain behavior or property we ha a Violation AKA Counterexamples.\n\nThe output of a Counterexample must show you exactly how to reproduce the violation, so you system can be fixed.\n\nWhen should I do a Model checking?\n\nAlways after implementation and before production deploy. It is untrue that a Software can be perfect during the planning or modeling phases. The beauty of software is that it can change many times before and after its implementation. Business needs flexibility, but we (developers) need to make sure it will work as expected after all those changes.\n",
        "url": "/software-architecture/2019/09/08/software-architecture-model-checking/"
      },
    
      {
        "title": "Emulate Android on Android Studio 3 using Mac OSX El Captain 10.11.6",
        "excerpt": "If you are having problems to emulate Android using Mac OSX El Captain 10.11.6, may this can help you.\n\n",
        "content": "If you are having problems to emulate Android using Mac OSX El Captain 10.11.6, may this can help you.\n\n\n\nIf when trying to run the emulation you got the following message:\n\nEmulator: Sorry, \"qemu-system-x86_64\" can not be run on this version of macOS. Qt requires macOS 10.12.0 or later, you have macOS 10.11.6.\n\n\nThe solution can be to downgrade your emulator version to Android Emulator Version 28.0.25.\n\nAfter download you should replace your current emulator with this one. The emulator for Android Studio generally is located on:\n\n/Users/{YOUR_USERNAME}/Library/Android/sdk/emulator\n\n\nSo you can just replace the files and restart your Android studio.\n",
        "url": "/android/macos/2019/09/10/android-emulator-does-not-work-macos-el-captain-10-11-6/"
      },
    
      {
        "title": "A brief overview about Software Design and Software architecture",
        "excerpt": "What is Software Design and Architecture? How they relate and differ each other?\n\n",
        "content": "What is Software Design and Architecture? How they relate and differ each other?\n\n\n\nTo try to understand Software Design/Architecture, we can do an analogy using a project of a house, for example:\n\nSoftware Architecture\n\nAs an architect, you would have high level concerns, such as:\n\n\n  How many people does it needs to support?\n  How many rooms does it have?\n  How are they connected / accessible?\n  What would be the best house position, angle, size?\n  What is the region where the house is located?\n  What materials should I use for that region?\n\n\nThese are higher level questions and show interactions of many “components” on a wide scope.\n\nSo during the architecture we need to know:\n\n\n  The big picture of the problem we need to solve.\n  What are the possible solutions.\n  Define how the “overall” solution would look like.\n  Raise the Necessary requirements for an stable and long living solution.\n  Define the quality tradeoffs.\n\n\nWhat is a quality trade-off?\n\nA tradeoff happens when to make an improvement you must sacrifice some other quality, for example: Adding security layer even if it costs some performance, makes the application safer.\n\nWhat are important skills for a Software Architect?\n\n\n  Tech Skills: Having good years of experience programing with different languages, databases, frameworks, solving problems in different scales, etc are mandatory.\n    \n      Design patterns.\n      Code standards.\n      Distributed processing.\n      Network.\n      Event Oriented and Object Oriented Programing.\n      …Any other Technology close to your professional scope. Example: An architect for mobile apps, must know cloud computing, mobile programing (i.e. Java), UI and so on.\n    \n  \n  \n    Business knowledge: An architect must be close to the business in order to clearly understand their needs and find the better approach to create a successful solution.\n  \n  \n    Organizational skills: Handle multiple concerns: Security, Performance, Business requirements, technical limitations, deadlines, etc.\n  \n  \n    Soft skills: It’s true that we use computers to create our applications, but we actually work with people for people. It’s important to maintain good relationship with colleagues from the team and other departments. Make the work environment pleasant and collaborative. Happy people produce more and do not get sick so often.\n  \n  Know what is available: Do not get stuck on your technologies and ideas. Always try to find out what is happening in the market, which technologies are available, what can you use? I mean, you do not need to know everything in details, but it comes handy when you have a problem to solve and plenty of alternatives to nail it.\n\n\nAs an Architect it is necessary to interact, collect feedback and meet the stakeholders expectations.\n\nWho are the Stakeholders and how the Software Architect interacts to them?\n\n\n  \n    Developers: The role of Architect is to provide a direction, organization and conceptual integrity for the developers towards to achieve the company goals in the better way possible.\n  \n  \n    Project Managers: The architect must inform the Project Manager about risks, dependencies, impact, task’s responsible and so.\n  \n  \n    Clients: Clients are the reason the system exists, cause they are funding it. The Architect must keep communication with clients to collect feedback and assure the system is being build according to their expectations.\n  \n  \n    End users: Users do not care (and might not even understand) how the software is built, but they care it is working properly. An architect must know the software is meeting to end users expectations and support the proper functional and no functional requirements to improve it.\n  \n\n\nSoftware Design\n\nStill considering the house project as example, the “Design” involves a low level scope, which means, we can can go on details for a given component.\n\nConsidering we need to build the kitchen, now the questions are:\n\n\n  How would the person interact with the kitchen?\n  How many sinks and which sizes we would need?\n  For plumbing, which pipes should we use, and in which disposition?\n  What will be the best material for this type of kitchen?\n  How would be better electrical wires connections to use, and how many plugs and sockets?\n\n\nWhen we enter in “implementation” details of a “component” we are talking about the design.\n\nBut what are the Stages of the Software Design?\n\nStage 1: Conceptual Design\n\nThis part is closer to the software behavior and functional validation.\n\n\n  Concept validation: Collect and validate customer requirements.\n  Conceptual mockups: Create mockups to help you visualize your problems in the earlier stage.\n  Validate mockups: Show, validate and adapt your mockups with the customers.\n  Create the CRC cards: Class Responsibility Collaborator cards will help you identify classes and components in your system and how they interact each other.\n  Reveal “hidden” questions: During the previous steps, many questions might come to you. Bring them to the customer, before moving forward.\n\n\nWhat is CRC (Class Responsibility Collaborator)?\n\nThis technique helps you see the relations between classes or components.\n\n\n  Class or Component: The class or components that interact with other class or components.\n  Responsibilities: The responsibilities of this component.\n  Collaborators: Components this component interacts with.\n\n\nStage 2: Technical Design\n\nThis part is closer to the software implementation.\n\n\n  Go into details: Turn the conceptual design into a more precise design, for example, start the UML class diagram.\n  Programing Define code structure and turn mockups into classes and then an application.\n\n\nCategories of objects\n\nDuring the technical design, many types of objects will be evidenced:\n\n\n  Entity Objects: Real world entities that know their rules and attributes. Example: Customer.\n  Boundary objects: Objects responsible to collect / send information to other systems. Example: Gateway, ContactForm.\n  Control objects: Objects that control other objects. Example: “Mediator”.\n\n\n",
        "url": "/software-architecture/2019/09/11/software-design-architecuture/"
      },
    
      {
        "title": "The 23 Design Patterns you must know",
        "excerpt": "Based on a famous book I will try to simplify and give examples of the \n23 famous design patterns that can help your daily work as developer.\n\n",
        "content": "Based on a famous book I will try to simplify and give examples of the \n23 famous design patterns that can help your daily work as developer.\n\n\n\nIf you do not know the book I am talking about, it is Design Patterns: Elements of Reusable Object-Oriented Software.\nEven nowadays the Book is still handy and we realize how timeless is its content.\n\nBefore we start\n\nSo what are Design Patterns?\n\nYes, Design Patterns are everywhere we need to do a recurring action.\n\nBesides construction, medicine, engineering, we have patterns also for teaching people, cooking (recipes), social interactions (greet, thanks, apologize), selling, designing packings and many many others areas.\n\nBasically, for any repeating task, by experience, the specialists found approaches that work better on each situation and then it becomes a pattern.\n\nAlong the history developers have solved similar problems with different solutions. It turned out that to solve common problems, some solutions provided a better result and made the code more ReFlexMain, which is Reusable, Flexible and Maintainable, the holy trinity.\n\nAs an Architect, Software Engineer or Developer, Design patterns will give to you the Foundation to solve more complex design problems.\n\nLets explore them!\n\nCreational Patterns\n\nDefine patterns to be used when creating or cloning objects.\n\nSingleton\n\nSingleton actually became an anti-patterns, because it brings many restrictions due the fact is is a single instance of an object, thus a global state in the whole application. It makes system more complex and hard to test.\n\nFor a matter of information, I will show the pattern here just for you to don not use it.\n\nGoals of the pattern:\n\n\n  Object must be globally accessible.\n  There must a single instance of an object for the whole application.\n\n\nBasically we make impossible to create an instance externally by making a private constructor and then we create a public static method to cache and retrieve the single global state of this class.\n\nExample in PHP:\n\n&lt;?php\nclass MySingleton\n{\n    private $instance;\n\n    private function __construct(){}\n\n    public static function getInstance(): MySingleton \n    {\n        if (null === $this-&gt;instance) {\n            $this-&gt;instance = new self();\n        }\n\n        return $this-&gt;instance;\n    }\n}\n\n\nFactory Object\n\nAs in the real world, the purpose of this patterns is also to create objects.\n\nBenefits:\n\n\n  Centralize object creation.\n  Avoid repeat code. DRY, since other parts of the system can use the factory.\n  Make code easier to maintain.\n  Decouple multiple responsibilities from classes.\n\n\nExample in Java:\n\npublic class PackageFactory\n{\n    public IPackage create(PackageType type)\n    {\n        IPackage package;\n\n        if (type.is('carrier')) {\n            package = new CarrierPackage();\n        } else if (type.is('post')) {\n            package = new PostPackage();\n        } else {\n            package = new OrdinaryPackage();\n        }\n\n        return package;\n    }\n}\n\n// Using the factory object\npublic class Shipping\n{\n    private PackageFactory packageFactory;\n\n    public Shipping(PackageFactory packageFactory)\n    {\n        this.packageFactory = packageFactory;\n    }\n\n    public void dispatch(PackageType type, Item item)\n    {\n        IPackage package;\n\n        package = this.packageFactory.create(type);\n        package.addItem(item);\n        package.close();\n        //... other implementation...\n    }\n}\n\n\nFactory method\n\nAs the factory object, this pattern also creates object, but in a separate method of specialized classes instead.\n\nWe can do this making the previously client of the factory an abstract class, so the subclasses will be specialized and responsible to decide which type of object to create.\n\nBenefits:\n\n\n  Code for interface rather than implementation.\n  Easier to extend the code.\n  Does not inflate factories.\n\n\npublic abstract class Shipping\n{\n    public void dispatch(PackageType type, Item item)\n    {\n        IPackage package;\n\n        package = this.createPackage(type);\n        package.addItem(item);\n        package.close();\n        //... other implementation...\n    }\n\n    abstract IPackage createPackage(PackageType type);\n}\n\npublic class CarrierShipping extends Shipping\n{\n    IPackage createPackage(PackageType type)\n    {\n        return new CarrierPackage();\n    }\n}\n\npublic class PostShipping extends Shipping\n{\n    IPackage createPackage(PackageType type)\n    {\n        return new PostPackage();\n    }\n}\n\npublic class OrdinaryShipping extends Shipping\n{\n    IPackage createPackage(PackageType type)\n    {\n        return new OrdinaryPackage();\n    }\n}\n\n\nStructural Patterns\n\nThese patterns describe how objects are connected to each other:\n\n\n  How they relate with generalization: Composition, Association, Aggregation, Inheritance or Interface\n  How classes and subclasses interact trough inheritance.\n\n\nFacade\n\nA client of a subsystem don’t want (and don’t need) to know the details of how it works internally. It just wants to request something in order to get something.\n\nA Facade is:\n\n\n  A point of entry to your subsystem(s).\n  A wrapper class to allow the client to interact with subsystems.\n  A pattern that puts all the complexity of the subsystems behind a “facade”\n\n\nKey principles to use a Facade\n\n\n  Encapsulation: Inject the necessary subsystem classes into the Facade.\n  Information Hiding: Do not expose subsystems to the client.\n  Separation of concerns: The client does not need to be concerned about subsystems implementations details or business rules.\n\n\nWhen to use Facade?\n\n\n  If you need a class to represent an interface between a subsystem and a client class.\n  To simplify the interaction between client and subsystems.\n\n\nExample in PHP:\n\n&lt;?php\ninterface IAccount\n{\n    public function getBalance(): float;\n    public function withdraw(float $amount): void;\n    public function deposit(float $amount): void;\n}\n\nclass InvestmentAccount implements IAccount {}\n\nclass SavingAccount implements IAccount {}\n\nclass CurrentAccount implements IAccount {}\n\nclass BankFacade\n{\n    public function accountBalance(string $accountNumber): float\n    {\n        $account = $this-&gt;accountRepository-&gt;find(accountNumber);\n\n        return $account-&gt;getBalance();\n    }\n\n    public function accountWithdraw(string $accountNumber, float $amount): void\n    {\n        $account = $this-&gt;accountRepository-&gt;find(accountNumber);\n\n        $account-&gt;withdraw($amount);\n    }\n\n    public function accountDeposit(string $accountNumber, float $amount): void\n    {\n        $account = $this-&gt;accountRepository-&gt;find(accountNumber);\n\n        $account-&gt;deposit($amount);\n    }\n\n    public function createAccount(string $type, string $customerName): Account\n    {\n        if ($type == 'saving') {\n            $account = new SavingAccount($customerName);\n        } elseif ($type == 'investment') {\n            $account = new InvestmentAccount($customerName);\n        } elseif ($type == 'current') {\n            $account = new CurrentAccount($customerName);\n        }\n\n        $this-&gt;accountRepository-&gt;save(accountNumber);\n\n        return $account;\n    }\n}\n\n/**\n * The client is not aware about internal behavior or implementation of subsystems. \n * It just know about the exposed functionality.\n */\nclass ApplicationClient\n{\n    private $bankFacade;\n\n    public function __construct(BankFacade $bankFacade)\n    {\n        $this-&gt;bankFacade = $bankFacade;\n    }\n\n    public function operation(string $operation, array $parameters)\n    {\n        if ($operation === 'new-account') {\n            return $this-&gt;bankFacade-&gt;createAccount($parameters['accountType'], $parameters['customerName']);\n        }\n\n        if ($operation === 'deposit') {\n            return $this-&gt;bankFacade-&gt;accountDeposit($parameters['accountNumber'], $parameters['amount']);\n        }\n\n        if ($operation === 'withdraw') {\n            return $this-&gt;bankFacade-&gt;accountWithdraw($parameters['accountNumber'], $parameters['amount']);\n        }\n\n        if ($operation === 'balance') {\n            return $this-&gt;bankFacade-&gt;accountBalance($parameters['accountType']);\n        }\n    }\n}\n\n\nAdapter\n\nThe output of a system might not comply with the expected input of another system. It requires an adapter to transform this output to an accepted input to the other system.\n\nInvolved parts to use the Adapter pattern:\n\n\n  Client: Class of your your system that wants to use a third-party library or external system.\n  Adaptee: It is the class in the third-party library or external library you want to use.\n  Adapter: It will adapt (or translate) the Adaptee to the Client and vice-versa.\n    \n      The Adapter must implements an Target Interface that the Adaptee understands.\n    \n  \n\n\nExample in Java:\n\n// This is the \"Target interface\"\npublic interface IWsRequester\n{\n    public Response request(Order order);\n}\n\n// This is the \"Adapter\"\npublic class WsAdapter implements IWsRequester\n{\n    //WebService is a third-party library class which we cannot change...\n    private WebService adaptee;\n\n    //...constructor\n\n    public Response request(Order order)\n    {\n        String json = this.orderToJson(order);\n\n        return this.adaptee.request(json);\n    }\n\n    private String orderToJson(Order order)\n    {\n        //... Adapts / translates Order object to JSON string\n    }\n}\n\n// This is the \"Client\"\npublic class WsClient\n{\n    private IWsRequest requester;\n\n    //...constructor\n\n    public void dispatchOrder(String orderNumber)\n    {\n        Order order = this.orderRepository.getOrder(orderNumber);\n\n        Response response = this.requester.request(order);\n\n        if (response.code === 200) {\n            System.out.println('Success!');\n        } else {\n            System.out.println('Error!');\n        }\n    }\n}\n\npublic class Main\n{\n    public static void main(String args[])\n    {\n        WebService adaptee = new WebService(\"http://external-system-url\");\n        WsAdapter adapter = new WsAdapter(adaptee);\n\n        WsClient client = new WsClient(adapter);\n\n        //Note that the client does not need to be aware of the \"adapteeo\" interface thanks to the adapter...\n        client.dispatchOrder(args[0]);\n    }\n}\n\n\nComposite\n\nObjectives:\n\n\n  To compose nested structures of objects.\n  To work uniformly (with Polymorphism) with the classes of these objects.\n\n\nMain components of the composite pattern:\n\n\n  Component Interface: All the objects that implements this interface can be another components or a Leaf.\n  Component: An implementation of the Component Interface that have aggregate other Components or Leaves.\n  Leaf: An implementation of the Component Interface that “cannot” aggregate other Components or Leaves\n\n\n\n  \n  UML class diagram composition pattern\n\n\nExample in Java\n\nimport java.util.ArrayList;\n\n/* [Program.java] */\npublic class Program {\n\tpublic static void main(String args[]) {\n\t\n\tPlaylist studyPlaylist = new Playlist(\"Study\");\t\t\n    Playlist rockPlaylist = new Playlist(\"Rock\");\n    \n\tSong rockSong1 = new Song(\"Nothing else matters\");\n    Song rockSong2 = new Song(\"Sultans of swing\");\n    \n\trockPlaylist.add(rockSong1);\n    rockPlaylist.add(rockSong2);\n    \n    Song studySong1 = new Song(\"Design Patterns\");\n    Song studySong2 = new Song(\"Software Architecture\");\n\n    studyPlaylist.setPlaybackSpeed(0.25f);\n    studyPlaylist.add(studySong1);\n    studyPlaylist.add(studySong2);\n\tstudyPlaylist.add(rockPlaylist);\n\tstudyPlaylist.play();\n}\n\npublic interface IComponent \n{\n    public void play();\n    public void setPlaybackSpeed(float speed);\n    public String getName();\n}\n\n// Component class\npublic class Playlist implements IComponent \n{\n\tpublic String playlistName;\n\tpublic ArrayList&lt;IComponent&gt; playlist = new ArrayList();\n\n    public Playlist(String playlistName) \n    {\n\t\tthis.playlistName = playlistName;\n    }\n    \n    public void play()\n    {\n        playlist.get(0).play();\n    }\n\n    public void setPlaybackSpeed(float speed)\n    {\n        for (IComponent song : playlist) {\n            song.setPlaybackSpeed(speed);\n        }\n    }\n\n    public String getName()\n    {\n        return playlistName;\n    }\n\n    public void add(IComponent component)\n    {\n        playlist.add(component);\n    }\n\n    public void remove(IComponent component)\n    {\n        playlist.remove(component);\n    }\n}\n\n// Leaf class\npublic class Song implements IComponent \n{\n\tpublic String songName;\n\tpublic float speed = 1;\n\n    public Song(String songName) \n    {\n\t\tthis.songName = songName;\n    }\n    \n    public void play()\n    {\n        System.out.println(\"Playing music ...\");\n    }\n\n    public void setPlaybackSpeed(float speed)\n    {\n        this.speed = speed;\n    }\n\n    public String getSongName()\n    {\n        return songName;\n    }\n}\n\n\nProxy\n\nWhy to use a proxy?\n\n\n  To act as a Virtual Proxy: If the resource is too big (i.e and image file) or we do not need all the resource we can access part of this resource through a Virtual Proxy.\n  To act as a Protection Proxy: Useful to control access to the real subject class.\n  To act as a Remote Proxy: When the proxy class is instantiated locally, but the subject classes are located remotely (I.e Google files stored locally in the Browser, but actual files are in the server).\n\n\n\n  \n  UML proxy pattern\n\n\n&lt;?php\n\n// The Subject interface\ninterface StockInterface\n{\n    public function processOrder(Order $order): void\n}\n\n// The class that will be Proxied. It does not check stock quantity...\nclass DistributionCenter implements StockInterface\n{\n    /** @var Stock[] **/\n    private $stocks;\n\n    public function processOrder(Order $order): void\n    {\n        foreach ($order-&gt;getItems() as $item) {\n            $stock = $this-&gt;getStock($item-&gt;getProduct());\n            $stock-&gt;decrease($item-&gt;getQuantity());\n        }\n    }\n\n    public function getStock(Product $product): Stock\n    {\n        foreach ($this-&gt;stocks as $stock) {\n            if ($stock-&gt;belongsTo($product)) {\n                return $stock;\n            }\n        }\n    }\n}\n\n// The proxy checks all distribution centers for a stock, otherwise raise an exception\nclass DistributionCenterProxy implements StockInterface\n{\n    /** @var DistributionCenter **/\n    private $distributionCenters;\n\n    public function processOrder(Order $order): void\n    {\n        foreach ($this-&gt;distributionCenters as $distributionCenter) {\n            $hasStock = true;\n\n            foreach ($order-&gt;getItems() as $item) {\n                $stock = $distributionCenter-&gt;getStock($item-&gt;getProduct());\n\n                if (!$stock-&gt;hasStock($item-&gt;getQuantity())) {\n                    $hasStock = false;\n\n                    break;\n                }\n            }\n\n            if ($hasStock) {\n                $distributionCenter-&gt;processOrder($order);\n\n                return;\n            }\n        }\n\n        throw new Exception('Insufficient stock');\n    }\n}\n\n\nDecorator\n\nSometimes we need to add some extra feature or behavior for a class, but we do not want to change the original class in order to preserve its individual purpose. The Decorator pattern uses aggregation to combine behaviors to a class at runtime!\n\nGoals:\n\n\n  Aggregates other types of components forming an “stack” of components on top of each other.\n  Serves as an Abstract superclass for concrete decorator classes where each one of them will increment behavior.\n  Allow add at runtime any number of behaviors using aggregation instead of inheritance.\n  The aggregation is always a one-to-one relationship with the object below in the stack.\n\n\n\n  \n  UML decorator pattern\n\n\n// The component interface\npublic interface IWebPage\n{\n    public void display();\n}\n\n// The concrete component\npublic class BasicWebPage implements IWebPage\n{\n    public void display()\n    {\n        // Output page content...\n    }\n}\n\n// The abstract Decorator\npublic abstract class WebPageDecorator implements IWebPage\n{\n    protected IWebPage webPage;\n\n    public WebPageDecorator(IWebPage webPage)\n    {\n        this.webPage = webPage;\n    }\n\n    public void display()\n    {\n        this.webPage.display();\n    }\n}\n\n// A concrete decorator. It does not aggregate any other IWebPage component\npublic class AuthenticationWebPage extends WebPageDecorator\n{\n    //constructor...\n\n    public void display()\n    {\n        super.display();\n        this.authenticateUser();\n    }\n\n    private void authenticateUser()\n    {\n        //Display authentication form\n    }\n}\n\n// A concrete decorator. It does not aggregate any other IWebPage component\npublic class AuthorizationWebPage extends WebPageDecorator\n{\n    //constructor...\n\n    public void display()\n    {\n        super.display();\n        this.authorizeUser();\n    }\n\n    private void authorizeUser()\n    {\n        //Display authorized user content\n    }\n}\n\npublic class Main\n{\n    public static void main(String args)\n    {\n        // Here is we can check the decorator adding behavior in stack\n        IWebPage basicPage = new BasicWebPage();\n        IWebPage authorizationPage = new AuthorizationWebPage(basicPage);\n        IWebPage authenticationPage = new AuthenticationWebPage(authorizationPage);\n        \n        authenticationPage.display();\n    }\n}\n\n\nBehavioral Patterns\n\nDefine how independent object work towards a common goal.\n\nTemplate Method\n\nWhen you want to establish the steps or behavior of some algorithm and allow customization only for part of it, we call it Template Method.\n\n\n  The template method defines the behavior in a Abstract superclass.\n  The superclass has an abstract method, that must be implemented by subclasses.\n\n\n\n  \n  UML template method pattern\n\n\nExample in PHP:\n\n&lt;?php\n\nabstract class Pizza\n{\n    public function prepare(): void\n    {\n        $this-&gt;addCover();\n        $this-&gt;addSauce();\n        $this-&gt;bake();\n    }\n\n    private function bake(): void\n    {\n        // Common Baking logic\n    }\n\n    public abstract function addCover(): void;\n    public abstract function addSauce(): void;    \n}\n\nclass PizzaMozzarella extends Pizza\n{\n    public function addCover(): void\n    {\n        // Add mozzarella cheese\n    }\n\n    public function addSauce()\n    {\n        // add olives and oregano\n    }\n}\n\nclass PizzaCarbonara extends Pizza\n{\n    public function addCover(): void\n    {\n        // Add parmesan, mozzarella, eggs and bacon\n    }\n\n    public function addSauce()\n    {\n        // add oregano\n    }    \n}\n\n\nChain of Responsibility\n\nWhen we crate a chain of objects working together to handle requests, we call it a Chain of Responsibility.\n\nGenerally they are a series of Handlers objects, each one specialized on handle some part of the requests.\n\nWhile the request is not satisfied by a handler, they will forward the request to the next handler in the chain.\n\n\n  \n  UML Chain of responsibility pattern\n\n\n&lt;?php\n\nabstract class RequestHandler\n{\n    /**\n     * @var Handler\n     */\n    protected $nextHandler;\n\n    public function setNextHandler(Handler $nextHandler): self\n    {\n        $this-&gt;nextHandler = $nextHandler;\n\n        return $this;\n    }\n\n    public abstract function handle(Request $request): Response;\n}\n\nclass UserAuthorizerHandler extends RequestHandler\n{\n    public function handle(Request $request): Response\n    {\n        if (!$request-&gt;getAttribute('authorized')) {\n            // Sends user to authorization...\n            return new Response();\n        }\n\n        return $next-&gt;handle($request, $response);\n    }\n}\n\nclass UrlRedirectHandler extends RequestHandler\n{\n    public function handle(Request $request): Response\n    {\n        if ($request-&gt;getUrl() === 'redirect') {\n            // Validate url and create redirect response...\n            return new Response();\n        }\n\n        return $next-&gt;handle($request, $response);\n    }\n}\n\nclass XssValidationHandler extends RequestHandler\n{\n    public function handle(Request $request): Response\n    {\n        if ($request-&gt;getQueryParam('search')) {\n            // If the parameter values corresponds to a XSS attack, block user...\n            return new Response();\n        }\n\n        return $next-&gt;handle($request, $response);\n    }\n}\n\n// Last handler, if everything went fine...\nclass LoadViewHandler extends RequestHandler\n{\n    public function handle(Request $request): Response\n    {\n        // Loads HTML page by request...\n        return new Response();\n    }\n}\n\n// ...request handling on index.php\n\n$handler1 = new UserAuthorizerHandler();\n$handler2 = new UrlRedirectHandler();\n$handler3 = new XssValidationHandler();\n$handler4 = new LoadViewHandler();\n\n$handler1-&gt;setNextHandler($handler2)\n    -&gt;setNextHandler($handler3)\n    -&gt;setNextHandler($handler4);\n\nreturn $handler1-&gt;handle($request);\n\n\nState pattern\n\nThe state pattern is used when you want to change the behavior off an object depending on its current state at run-time.\n\nLets see the example in Java. Instead of have lots of conditions inside the ATM class, we distribute the responsibilities to each possible “state” of the ATM machine.\n\nclass Atm\n{\n    private float balance;\n    private AtmState currentState;\n    private NoFundsState noFundsState;\n    private HasFundsState hasFundsState;\n    private IdleState idleState;\n\n    public Atm()\n    {\n        idleState = new IdleState(this);\n        noFundsState = new NoFundsState(this);\n        hasFundsState = new HasFundsState(this);\n        currentState = idleState;\n    }\n\n    public void withdraw(float amount)\n    {\n        currentState.withdraw(amount);\n    }\n\n    public void deposit(float amount)\n    {\n        currentState.deposit(amount);\n    }\n\n    public float getBalance()\n    {\n        return balance;\n    }\n\n    public void addMoney(float money)\n    {\n        this.balance += money;\n    }\n\n    public void removeMoney(float money)\n    {\n        this.balance -= money;\n    }\n\n    public void setCurrentState(AtmState currentState)\n    {\n        this.currentState = currentState;\n    }\n\n    public HasFundsState getHasFundsState()\n    {\n        return this.hasFundsState;\n    }\n\n    public NoFundsState getNoFundsState()\n    {\n        return this.noFundsState;\n    }\n\n    public IdleState getIdleState()\n    {\n        return this.idleState;\n    }\n}\n\nabstract class AtmState\n{\n    protected Atm atm;\n\n    public AtmState(Atm atm)\n    {\n        this.atm = atm;\n    }\n\n    public abstract void withdraw(float amount);\n    public abstract void deposit(float amount);\n}\n\nclass NoFundsState extends AtmState\n{\n    public void withdraw(float amount)\n    {\n        throw new NoFundsException(\"No funds\");\n    }\n\n    public void deposit(float amount)\n    {\n        super.atm.addMoney(amount);\n        super.atm.setState(super.atm.getHasFundsState());\n    }\n}\n\nclass HasFundsState extends AtmState\n{\n    public void withdraw(float amount)\n    {\n        if (super.atm.getBalance() &lt; amount) {\n            throw new NoFundsException(\"No funds\");\n        }\n\n        super.atm.removeMoney(amount);\n\n        if (super.atm.getBalance() &lt;= 0) {\n            super.atm.setState(super.atm.getNoFundsState());\n        }\n    }\n\n    public void deposit(float amount)\n    {\n        super.atm.addMoney(amount);\n    }\n}\n\nclass IdleState extends AtmState\n{\n    public void withdraw(float amount)\n    {\n        if (super.atm.getBalance() &lt; amount) {\n            throw new NoFundsException(\"No funds\");\n        }\n            \n        super.atm.removeMoney(amount);\n\n        if (super.atm.getBalance() &lt;= 0) {\n            super.atm.setState(super.atm.getNoFundsState());\n        } else {\n            super.atm.setState(super.atm.getHasFundsState());\n        }\n    }\n\n    public void deposit(float amount)\n    {\n        super.atm.addMoney(amount);\n        super.atm.setState(super.atm.getHasFundsState());\n    }\n}\n\n\nCommand\n\nThe command encapsulates a request in an object its own. So this command must be forward to a Worker which knows how to execute this command.\n\n(Sender) -Creates-&gt; (Command) -Calls_Method-&gt; (Receiver);\n\n\nObjects involved in the Command pattern.\n\n\n  Sender: The object that needs some request to be done.\n  Command: The encapsulated request in a way that the Receiver knows how process it.\n  Receiver: The object that knows how to execute an specific Command.\n  Invoker: The object that invokes Command object to complete whatever tasks it does.\n  Command Manager: A object to keep track of the commands to be executed.\n\n\nUndo/Redo or Memento using Command pattern\n\nSometimes you need to keep track of all the state changes of an object, so you can easily move back and forth to a program state. A real world example is the undo/redo of text editors. So every time you do a change in the editor you put a command at the top of a stack.\n\nThis pattern can be used in conjunction with the Command pattern\n\n\n  \n  UML Command and Memento pattern\n\n\nSe the example in PHP integrating Memento with Command pattern:\n\n&lt;?php \ninterface Receiver\n{\n    public function execute(array $data);\n}\n\nclass EraseTextReceiver implements Receiver\n{\n    public function execute(array $data): void\n    {\n        //Erase from file: $data['file'], strlen($data['text']), $data['position'];\n    }\n}\n\nclass WriteTextReceiver implements Receiver\n{\n    public function execute(array $data): void\n    { \n        //Write in the file: $data['file'], $data['text'], $data['position'];\n    }\n}\n\nclass SaveFileReceiver implements Receiver\n{\n    public function execute(array $data): void\n    {\n        //Save file contents from $data['file']\n    }\n}\n\nabstract class Command\n{\n    abstract public function do(): void;\n    abstract public function undo(): void;\n    abstract public function isReversible(): bool;\n}\n\nclass WriteCommand extends Command\n{\n    private $writeReceiver;\n    private $eraseFileReceiver;\n    private $data;\n\n    public function __construct(\n        WriteFileReceiver $writeReceiver, \n        EraseFileReceiver $eraseFileReceiver,\n        array $data\n    ) {\n        $this-&gt;writeReceiver = $writeReceiver;\n        $this-&gt;eraseReceiver = $eraseFileReceiver;\n        $this-&gt;data = $data;\n    }\n\n    public function do(): void\n    {\n        $this-&gt;writeReceiver-&gt;execute($this-&gt;data);\n    }\n    \n    public function undo(): void\n    {\n        $this-&gt;eraseReceiver-&gt;execute($this-&gt;data);\n    }\n\n    public function isReversible(): bool\n    {\n        return true;\n    }\n}\n\nclass SaveCommand extends Command\n{\n    private $data;\n\n    public function __construct(array $data) \n    {\n        $this-&gt;data = $data;\n    }\n\n    public function do(array $data): void\n    {\n        // Save file: $this-&gt;data['file'];\n    }\n    public function undo(array $data): void\n    {\n         // cannot undo save\n    }\n\n    public function isReversible(): bool\n    {\n        return false;\n    }\n}\n\n/**\n * Manage command execution, queue, etc\n * \n * Here we are using \"Memento pattern\" where we have two queues \"history\" and \"undoHistory\".\n */\nclass CommandManager\n{\n    private $history = []; //Queue for doing commands\n    private $undoHistory = []; //Queue for undoing commands\n\n    public function doCommand(Command $command)\n    {\n        $this-&gt;history[] = $command;\n\n        $command-&gt;do();\n    }\n\n    public function undoCommand()\n    {\n        $last = count($this-&gt;history) - 1;\n\n        if (!isset($this-&gt;history[$last])) {\n            return;\n        }\n\n        $lastCommand = $this-&gt;history[$last];\n\n        unset($this-&gt;history[$last]);\n\n        $this-&gt;undoHistory[] = $lastCommand;\n\n        if ($lastCommand-&gt;isReversible()) {\n            $lastCommand-&gt;undo();\n        }\n    }\n\n    public function redoCommand()\n    {\n        $last = count($this-&gt;undoHistory) - 1;\n\n        if (!isset($this-&gt;undoHistory[$last])) {\n            return;\n        }\n\n        $lastCommand = $this-&gt;undoHistory[$last];\n\n        unset($this-&gt;undoHistory[$last]);\n\n        $this-&gt;history[] = $lastCommand;\n\n        $lastCommand-&gt;do();\n    }\n}\n\n// Interacts with command manager and commands\nclass Invoker\n{\n    /**\n     * @var CommandManager\n     */\n    private $commandManager;\n\n    public function invoke()\n    {\n        $file = new File();\n        $writeTextReceiver = new WriteTextReceiver();\n        $eraseTextReceiver = new EraseTextReceiver();\n        $saveReceiver = new SaveFileReceiver();\n\n        $command1 = new WriteCommand(\n            $writeTextReceiver, \n            $eraseTextReceiver, \n            [\n                'file' =&gt; $file,\n                'text' =&gt; 'Hello Word', \n                'position' =&gt; 0,\n            ]\n            \n        );\n        $command2 = new WriteCommand(\n            $writeTextReceiver, \n            $eraseTextReceiver, \n            [\n                'file' =&gt; $file,\n                'text' =&gt; 'Another text', \n                'position' =&gt; 9,\n            ]\n        );\n        $command3 = new SaveCommand(\n            [\n                'file' =&gt; $file,\n            ]\n        );\n\n        /**\n         * Here we can check memento working with Command pattern\n         */\n        $this-&gt;commandManager-&gt;doCommand($command1);\n        $this-&gt;commandManager-&gt;doCommand($command2);\n        $this-&gt;commandManager-&gt;doCommand($command3);\n\n        $this-&gt;commandManager-&gt;undoCommand(); // Cannot undo save\n        $this-&gt;commandManager-&gt;undoCommand(); // Will remove \"Another text\" from file\n\n        $this-&gt;commandManager-&gt;redoCommand(); // Will add again \"Another text\" to file\n\n        $this-&gt;commandManager-&gt;undoCommand(); // Will remove \"Another text\" from file\n        $this-&gt;commandManager-&gt;undoCommand(); // Will remove \"Hello World\" from file\n    }\n}\n\n\nMediator\n\nWhen we need some objects to interact each other based on some events, sometimes create an direct relation could be difficult to maintain. As these objects can grow in different directions, we do not want them to being coupled.\n\nImagine that you have a Smart House where you object can take different actions based on some events or other objects states. For instance, when your house temperature is too cold, the Air Conditioning should increase temperature. Or when you enter at home after a day of work, a coffee should be prepared. If it is Sunday morning 9AM, turn on the TV with the News.\n\nIt would be really difficult to maintain those objects aware about each other states. There comes handy the Mediator to do the job.\n\n\n  \n  UML Mediator pattern\n\n\nIn this pattern we call these objects that talk to the Mediator, Colleagues. The Colleagues can notify the Mediator through the Observer Pattern. So, for instance when some relevant event happens with the Thermostat, like “Temperature changed”, the Mediator is notified.\n\n\n  \n  Mediator UML class diagram\n\n\n&lt;?php\nabstract class Mediator implements SplObserver {}\n\nabstract class Colleague implements SplSubject\n{\n    public function attach(SplObserver $observer)\n    {\n        // Attach Mediator\n    }\n\n    public function detach(SplObserver $observer)\n    {\n        // Detach Mediator\n    }\n\n    public function notify()\n    {\n        //Call Mediator::update\n    }\n}\n\nclass HouseMediator extends Mediator\n{  \n    public function update(SplSubject $publisher)\n    {\n        // Check the subject. If is Temperature update by thermostat, change the air conditioning\n    }\n}\n\nclass Thermostat extends Colleague\n{\n    public function updateCurrentTemperature(float $temperature): void\n    {\n        // Notify mediator\n        $this-&gt;notify();\n    }\n}\n\nclass AirConditioning extends Colleague\n{\n    public function changeTemperature(float $temperature): void\n    {\n        // Change air conditioning temperature accordingly\n    }\n}\n\n\nObserver\n\nWhen we need to keep objects “observing” changes on other objects (subjects) we use the Observer pattern. This pattern contains main classes:\n\n\n  Observer: The objects that wants to be notified when something occurs with the Subject.\n  Subject: The object containing one or more observers related and responsible to notify than when something occurs.\n\n\n\n  \n  Observer UML class diagram\n\n\nExample in Java:\n\npublic interface Subject \n{\n    public void addObserver(Observer observer);\n    public void removeObserver(Observer observer);\n    public void notifyObservers();\n}\n\npublic interface Observer \n{\n\tpublic void update(Subject subject);\n}\n\npublic class Shipping implements Subject \n{\n    private ArrayList&lt;Observer&gt; observers;\n    private String productId;\n    private String status;\n\n    public void changeShippingStatus(String productId, String status)\n    {\n        this.productId = productId;\n        this.status = status;\n\n        this.notifyObservers();\n    }\n\n    public String getProductId()\n    {\n        return this.productId;\n    }\n\n    public String getStatus()\n    {\n        return this.status;\n    }\n    \n    public void addObserver(Observer observer)\n    {\n        if (!this.observers.contains(observer)) {\n            this.observers.add(observer);    \n        }\n    }\n    \n    public void removeObserver(Observer observer)\n    {\n        if (this.observers.contains(observer)) {\n            this.observers.remove(observer);\n        }\n    }\n    \n    public void notifyObservers()\n    {\n        for (Observer observer : this.observers) {\n            observer.update(this);\n        }\n    }\n}\n\npublic class Customer implements Observer\n{\n    private String name;\n    \n    public Customer(String name)\n    {\n        this.name = name;\n    }\n    \n    public void update(Subject subject)\n    {\n        System.out.println(\"Product \" + subject.getProductId() + \" shipping status is now \" + subject.getStatus() + \"!\");\n    }\n}\n\n\nOther patterns\n\nModel View Controller (MVC)\n\n\n  Model: It is part of the Business Layer. A self contained object which is totally independent from View and Controller. Generally is responsible to manage business rules, entities, persistence, etc. It provider data to controller, so they can be forward to the view.\n  View: It is part of the Presentation layer. It receives data from controller and renders the visualization for user. (I.e HTML content, JSON response, etc). It also receives data from user and forward to the Model.\n  Controller: It is an intermediary object it does the connection between View and Model making the Model loosely coupled to the View.\n\n\nExample:\n\nclass Controller\n{\n    private $model;\n    private $view;\n\n    public function __construct(ProductModel $model, ProductView $view)\n    {\n        $this-&gt;model = $model;\n        $this-&gt;view  = $view;\n    }\n\n    public function listProducts(Request $request)\n    {\n        $products = $this-&gt;model-&gt;getProducts(\n            [\n                'searchTerm' =&gt; $request-&gt;getQueryParam('term')\n            ]\n            \n        );\n\n        $this-&gt;view-&gt;render($products);\n    }\n}\n\n",
        "url": "/software-architecture/design-patterns/2019/09/12/the-23-design-patterns-you-must-know/"
      },
    
      {
        "title": "Code Smells & Anti-patterns",
        "excerpt": "Here a brief list of some code smells and what to do to get ride from them.\n\n",
        "content": "Here a brief list of some code smells and what to do to get ride from them.\n\n\n\nComments\n\nIf you have to write a comment to explain what the code is doing, probably you used a poor design, code is doing too much or you are not sure what it is doing.\n\nHow to get ride of comments?\n\nAvoid comments and prefer separations of concerns, smaller and specialized classes with self-explainable names. A class and method’s purpose should be clear just by reading its name. Avoid creating to generic classes like “CustomerService” that does everything. Instead use specialized classes like: UpdateCustomerService, SendCustomerInvoiceService, etc. By reading the name is really easy to know what is the class purpose.\n\nLong methods\n\nThe name is self-explainable. A long method most probably is doing more than what should and it is hard to understand. But what could be considered long? There is no magic number, i will depend on the language you are using and what is being done.\n\nHow to avoid long methods\n\n\n  Use separation of concerns.\n  Split the code in sub-methods with meaningful names.\n  Split class in multiple classes.\n\n\nLong parameters list\n\nIf you have a really long list of parameters, probably your method either is doing more than it should or the class is fat. It can cause some complications, cause every time you need to change or add behavior on this class you need to add a new parameter, that sometimes will ignore previous parameters or even add a lot of optional parameters.\n\nIt is a pain to maintain such class or method, cause it bring high coupling and low cohesion.\n\nHow to avoid long parameters list?\n\n\n  Create new objects encapsulating the parameters. For example, in a program about geo location, a class with parameters “x, y, z” could become an object called “Point3D” and “latitude, longitude” might become a “Coordinates” object.\n  Segregate methods in more specialized methods / classes. Sometimes you have a long list of parameters, cause your class / method has multiple concerns.\n\n\nAccording to Robert Martin in the book Clean Code methods should be monad, dyad or triad. This means. Have maximum three parameters on the worst cases.\n\nData classes\n\nData classes can be considered a code smell, when they are over abused and logic concerned to those classes are treated in separate classes when could be done in the same class.\n\nA data class is basically a class the contain only getters and setters (sometimes). Of course, Values objects or data objects can be useful to normalization, but there are some cases they are not used only for this.\n\nHow to avoid data classes?\n\nCheck if these classes should not be doing another kind of operation besides encapsulation, for example, calculating or checking something, etc that could being done by another classes.\n\nData clumps\n\nSometimes we start copying data from one class to another just for the sake of “save time” and end up generating a series of duplications. These parameters should become their own classes. For example. Imagine that you copy the database credentials in many services to create a new connection object.\n\nHow to avoid data clamps\n\nProbably these credentials should become a self-contained object (Parameter Object) holding the necessary data a Connection needs. Or even make the Connection be instantiated one a single place like a DI container avoiding the duplication.\n\nDivergent change\n\nWhen you have to change a class in multiple ways for multiple reasons, then you have a Divergent change. This is because you have a Large class code smell where the class is doing to much for too many purposes. A poor separation of concerns Design is generally the main cause.\n\nHow to avoid a divergent change\n\n\n  Use proper separation of concerns.\n  Split large class into specialized classes.\n\n\nShotgun Surgery\n\nWhen to support a new requirement to your system you have to do a change to a lot of places instead of a centralized location. This is called Shotgun Surgery and probably was caused by poor design choices and violation of Design principles.\n\nHow to avoid it?\n\n\n  Respect Design principles.\n  Use SOLID principles.\n  Centralize object creations and business rules validations.\n\n\nFeature Envy\n\nWhen a method in one class constantly talks to a method of another class and vice-versa, and this method is only used for this purpose, probably they should be together in the same class. Of course, it is not always the case. Sometimes these methods are to complex and their responsibilities should be separated in other class.\n\nHow to avoid Feature Envy?\n\n\n  Consider moving the common method to class it concerns.\n\n\nInappropriate intimacy\n\nWhen two classes depending to much each other in a two-way communication, they were probably split by mistake or should be talking each other in a non-coupled way.\n\nHow to remove Inappropriate intimacy\n\n\n  Try to unify the classes into once.\n  Extract methods both classes use in another class.\n  Try to use a non-coupled approach like Observer pattern.\n\n\nMessage chains\n\nWhen your class method depends on a chain of methods to get its job done, than you have a message chain problem. It causes rigidity and complexity on your design. Example:\n\n\npublic class A\n{\n    public void do()\n    {\n        this.b.getC().getD().do(); // Demeter's law violation\n    }\n}\n\n\nHow to avoid message chains?\n\n\n  Respect the Law of Demeter.\n\n\nPrimitive obsession\n\nIt happens when you rely too much on primitive or built-in types, like: Int, Float, String, etc. For sure these types will be used, but we should try to retain its usage to low levels of our implementation.\n\nHow to avoid Primitive obsession\n\n\n  Create your own objects to represent primitive values with particular purpose. Example:\n    \n      The “postal code”, could be handled as a “String” all over your system, but you can easily encapsulate and validate it inside a a class “PostalCode”.\n    \n  \n  Avoid passing collection of primitives that represents important subjects in your system. Prefer to implement a collection class.\n\n\nSwitch statements\n\nSwitch statements (and if / else) are code smells when they try to replace Polymorphism. Example:\n\n&lt;?php\n\nclass Processor\n{\n    public function process(Order $oder, string $paymentType)\n    {\n        switch $paymentType\n        {\n            'creditCard':\n                $this-&gt;cardProcessor-&gt;process($order);\n                break;\n            'payPal':\n                $this-&gt;payPalProcessor-&gt;process($order);\n                break;\n            default:\n                $this-&gt;defaultPalProcessor-&gt;process($order);\n                break;\n        }\n    }\n}\n\n\nHow to avoid it?\n\nInstead, use Polymorphism:\n\n&lt;?php\ninterface IOrderProcessor\n{\n    public function process(Order $order): void;\n    public function supportsPaymentType(string $type): bool;\n}\n\nclass PaypalProcessor implements IOrderProcessor\n{\n    public function process(Order $order): void { /* ... */}\n    public function supportsPaymentType(string $type): bool\n    {\n        return 'paypal';\n    }\n}\n\nclass CreditCardProcessor implements IOrderProcessor\n{\n    public function process(Order $order): void { /* ... */}\n    public function supportsPaymentType(string $type): bool\n    {\n        return 'creditCard';\n    }\n}\n\nclass DefaultProcessor implements IOrderProcessor\n{\n    public function process(Order $order): void { /* ... */}\n    public function supportsPaymentType(string $type): bool\n    {\n        return true;\n    }\n}\n\n/**\n * As you can see we can add as many Order Processors we without increase the method complexity.\n */\nclass Processor\n{\n    /**\n     * @var IOrderProcessor[]\n     */\n    private $orderProcessors;\n\n    public function process(Order $oder, string $paymentType)\n    {\n        foreach ($this-&gt;orderProcessors as $orderProcessor) {\n            if ($orderProcessor-&gt;supportsPaymentType($paymentType)) {\n                $orderProcessor-&gt;process($order)\n            }\n        }\n    }\n}\n\n\nSpeculative Generality\n\nThis code smell happens when code is created, but it is not used (or not needed) because we think that “We might need this come day”. The “code”, could be a feature, superclass or even and interface that is not necessary.\n\nImagine for instance that you create an interface that is used by a single class, just because “someone” might need to generalize this in the future. It is against Agile Development and Just In Time (JIT) delivery. You do not want to waste time writing code that is not needed.\n\nHow to avoid Speculative generality?\n\n\n  Keep the code simple.\n  Make code flexible, but avoid over-engineering. Find a balance.\n  Do not create code based on assumptions that feature will evolve. Requirements are dropped and priority drops every time, so do not waste time.\n\n\nRefused bequest\n\nMight happen you create a super class very useful for many cases, so subclass might inherit something it does not need.\n\nHow to avoid?\n\n\n  Does it make sense to extend this class? Maybe not.\n  Try to extract the unused behavior from super class.\n  Maybe defined this behaviors in the subclasses only.\n\n",
        "url": "/design-principles/2019/09/24/code-smells/"
      },
    
      {
        "title": "Law of Demeter - Least Knowledge Principle",
        "excerpt": "A class should know as less as possible about other classes implementation. There is a law for it!\n\n",
        "content": "A class should know as less as possible about other classes implementation. There is a law for it!\n\n\n\nA class should only know about first implementation of its “immediate fried” classes. This is important to avoid coupling and make your system more flexible, reusable, maintainable and with low coupling.\n\nExample:\n\nLet’s check the allowed usages:\n\nclass A\n{\n    private C c;\n\n    public void doB(B b)\n    {\n        b.do(); // Allowed!\n    }\n\n    public void doC()\n    {\n        this.c.do(); // Allowed!\n    }\n\n    public void doD()\n    {\n        D d = new D();\n\n        d.do(); // Allowed!\n    }\n}\n\n\nAnd these are not allowed:\n\nclass A\n{\n    private C c;\n\n    public void doB(B b)\n    {\n        b.do().doAgain(); // NOT Allowed!\n    }\n\n    public void doC()\n    {\n        this.c.do().doAgain(); // NOT Allowed!\n    }\n\n    public void doD()\n    {\n        D d = new D();\n\n        d.do().doAgain(); // NOT Allowed!\n    }\n\n    public void setC(C2 c)\n    {\n        this.c = c;\n\n        this.c.do(); // NOT Allowed, cause C2 is a base class of C and A only knows C!\n    }\n}\n\n",
        "url": "/design-principles/2019/09/25/law-of-demeter/"
      },
    
      {
        "title": "Dependency Inversion Principle - DIP",
        "excerpt": "Avoid making classes depending on concrete class to reduce coupling. Reduce the maintenance effort and risk of your system.\n\n",
        "content": "Avoid making classes depending on concrete class to reduce coupling. Reduce the maintenance effort and risk of your system.\n\n\n\nThe Dependency Inversion principle says that classes should relay on generalizations rather than implementation details.\n\nTo accomplish this always develop oriented to interfaces, not implementation. Extract the behavior representation of classes to interfaces and abstract classes, so they can easily be replaced.\n\n",
        "url": "/design-principles/solid/2019/09/26/dependency-inversion-principle/"
      },
    
      {
        "title": "Interface Segregation Principle - ISP",
        "excerpt": "A class should not be forced to do what it does not do. What? Yes, the way you built interfaces can cause this side effect.\n\n",
        "content": "A class should not be forced to do what it does not do. What? Yes, the way you built interfaces can cause this side effect.\n\n\n\nThe Interface Segregation Principle (ISP) says says that class should not be forced to depend on method it does not use.\n\nTo table this, segregate a interfaces in more and specialized ones.\n\nExample:\n\nImagine that you want to extract Bird behaviors for an interface.\n\ninterface Bird\n{\n    public void putEggs();\n    public void peck();\n    public void fly();\n    public void land();\n}\n\n\nSeems good, right? But what about penguins, chickens or other birds that does not fly? To solve this we can segregate the Bird interfaces in more specialized ones:\n\ninterface Bird\n{\n    public void putEggs();\n    public void peck();\n}\n\ninterface Flying\n{\n    public void fly();\n    public void land();\n}\n\nclass Penguin implements Bird\n{\n    //...\n}\n\nclass Chicken implements Bird\n{\n    //...\n}\n\nclass Falcon implements Bird, Flying\n{\n    //...\n}\n\n",
        "url": "/design-principles/solid/2019/09/27/interface-segregation-principle/"
      },
    
      {
        "title": "Open / Closed Principle - OCP",
        "excerpt": "The Open/Close Principle says that a class must be open for extension, but closed to change. Let’s take a look on it.\n\n",
        "content": "The Open/Close Principle says that a class must be open for extension, but closed to change. Let’s take a look on it.\n\n\n\nIf classes are tested, stable and the system is proven to be working with those, probably you do not want (need) to change then to add more features. So the classes will be open for extension, but closed to changes.\n\nTo overcome this you can use polymorphism to add new features by inheritance or implementing same interfaces.\n",
        "url": "/design-principles/solid/2019/09/28/open-closed-principle/"
      },
    
      {
        "title": "Liskov Substitution Principle - LSP",
        "excerpt": "Lets talk about Liskov Substitution Principle and how inheritance should be implemented. Yes, we are talking about the “L” from SOLID Design Principles.\n\n",
        "content": "Lets talk about Liskov Substitution Principle and how inheritance should be implemented. Yes, we are talking about the “L” from SOLID Design Principles.\n\n\n\nImplementing inheritance in a wrong way could be a trap for you, even worse than maintaining only concrete classes.\n\nWhen different subclasses start changing the behavior of the program by being replaced by each other, then hidden behaviors are introduced and it will cause inconsistency and implying to add extra conditions to “workaround” these anomalies. From that point is all the way down.\n\nThe Liskov substitution principle (LSP) defines about subtyping relation by (strong) behavioral subtyping. It says:\n\n\n If S is a subtype of T, then objects of type T in a program may be replaced with objects of type S without altering any of the desirable properties of that program\n\n\nThe 4 major rules to comply to LSP are:\n\n1. Subclass cannot decide base class method invocation\n\nA subclass MUST NOT add extra conditions to a base class method be called.\n\n2. Base class state cannot differ\n\nThe base class state after a call from a subclass cannot be different if the call is done by another subclass. The results should be the same.\n\n3. Invariants from base class must remain in subclasses\n\nThe invariant conditions should be immutable, so subclasses should not change them an cause side effects in the behavior of the program or base class.\n\n4. Immutable characteristics from based class should not be changed\n\nThe base class sometimes have its own attributes that are or not encapsulated, if changing these attributes changes the base class state, so they are immutable. Avoid protected attributes as much as you can. Update these attributes can cause undesired side effects in the program or base class.\n\nExample\n\n&lt;?php\n// Base class\nabstract class ProductSearch\n{\n    /**\n     * @throws InvalidArgumentException\n     */\n    private function validateCommand(SearchCommand $search) \n    { \n        //... \n    }\n\n    abstract protected function executeSearch(SearchCommand $search): array;\n\n    abstract protected function normalizeResult($item): ResultItem;\n\n    public function search(SearchCommand $search): SearchSummary\n    {\n        $this-&gt;validateCommand($search);\n\n        $results = $this-&gt;processResults($search);\n        \n        $summary = new SearchSummary();\n        $summary-&gt;setTotal(count($results));\n        $summary-&gt;setResult(\n            array_map(\n                function ($item): ResultItem\n                {\n                    return $this-&gt;normalizeResult($item);\n                },\n                $results\n            )\n        );\n\n        return $summary;\n    }\n}\n\n// Subclass, does not change behavior\nclass ElasticSearchProductSearch extends ProductSearch\n{\n    protected function executeSearch(SearchCommand $search): array\n    {\n        // return specific ElasticSearch results\n    }\n\n    protected function normalizeResult($item): ResultItem\n    {\n        // return normalized ElasticSearch result item\n    }\n}\n\n// Subclass, does not change behavior\nclass MySQLProductSearch extends ProductSearch\n{\n    protected function executeSearch(SearchCommand $search): array\n    {\n        // return specific MySQL results\n    }\n\n    protected function normalizeResult($item): ResultItem\n    {\n        // return normalized MySQL result item\n    }\n}\n\n// Subclass, does not change behavior\nclass RedisProductSearch extends ProductSearch\n{\n    protected function executeSearch(SearchCommand $search): array\n    {\n        // return specific Redis results\n    }\n\n    protected function normalizeResult($item): ResultItem\n    {\n        // return normalized Redis result item\n    }\n}\n\nclass SearchController\n{\n    /**\n     * @var ProductSearch\n     */\n    private $productSearch;\n\n    protected function search(Request $request): SearchSummary\n    {\n        $results = $this-&gt;productSearch-&gt;search(\n            new SearchCommand(\n                $request-&gt;getQueryParam('term')\n            )\n        );\n\n        return $this-&gt;view-&gt;render($results);\n    }\n}\n\n\n\n",
        "url": "/design-principles/solid/2019/09/29/liskov-solid-substitution-principle/"
      },
    
      {
        "title": "Kruchten's 4 + 1",
        "excerpt": "The Kruchten’s 4 + 1 technique consists to represent how a system should be implemented by dividing it in 4 different views that are discovered through some business Scenarios or “Stories”.\n\n",
        "content": "The Kruchten’s 4 + 1 technique consists to represent how a system should be implemented by dividing it in 4 different views that are discovered through some business Scenarios or “Stories”.\n\n\n\n\n  \n  Source: https://upload.wikimedia.org/wikipedia/commons/e/e6/4%2B1_Architectural_View_Model.svg\n\n\nLogical View\n\nThis view’s intent is to capture the software functionality provided to the end-users. Here we can abstract the actors and process of our system in classes.\n\nThe UML Diagrams used here are:\n\n\n  Class Diagram\n  State Diagram\n\n\nProcess View\n\nTo show how process and subprocess interaction within the logical view. The efficiency and performance of the system comes in evidence here.\n\nThe UML Diagrams used here are:\n\n\n  Activity Diagram\n  Sequence Diagram\n\n\nDevelopment view\n\nThis view focus on implementation details, such as hierarchical structure of the software and other constraints from programing the language and technologies used.\n\nThe UML Diagrams used here are:\n\n\n  Component Diagram\n  Package Diagram\n\n\nPhysical View\n\nHere we can map how system interact with physical devices. The deployment process generally is part of the Physical view.\n\nThe UML Diagrams used here are:\n\n\n  Deployment Diagram\n  Package Diagram\n\n",
        "url": "/software-architecture/2019/10/01/kruchtens-4-1-view-model/"
      },
    
      {
        "title": "Software Architectural Styles",
        "excerpt": "A brief overview about the main software architectural styles and why and when we use them.\n\n",
        "content": "A brief overview about the main software architectural styles and why and when we use them.\n\n\n\nLanguage-based Systems\n\nThe programing language you choose to build your software will define the way you will architect it due their limitations or advantages.\n\nFor instance, a OOP (i.e. Java) will probably give you a better domain abstraction than a procedural language (i.e. C), but you cost you more performance and wont work for embedded software.\n\nAbstract Types and Object Oriented\n\nUsing a OOP paradigm we have better application of “Abstraction”, “Encapsulation” and “Decomposition” principles. The code produced can better translate the business language and generally the learning curve is smaller. High-level programing languages generally are intuitive and have lots of third-party libraries that already solve common problems.\n\nThe cons is that it generally implies less performance and higher computational power is required. It is more difficult (and impossible sometimes) to create lightweight or embedded software with this paradigm.\n\nUsages:\n\n\n  Management and administrative systems.\n  Web apps.\n  Mobile apps.\n\n\nMain program and Subroutines\n\nThis paradigm consists in usage of procedural code based on routines and subroutines sharing globals variables and procedures. It advantage is a very lightweight and highly performative software that consumes less computational power and energy. The cons is that is really difficult to maintain and the learning curve is higher. Low-level programing languages are generally not intuitive at all do not translate well the business language.\n\nUsages:\n\n\n  Embedded software.\n  Computational focused systems.\n\n\nRepository Based Systems\nWhen it is needed to shared data within modules and components an often used solution is a Data Centric Software Architecture.\n\nDatabases\nAt the core of a Data Centric architecture are 2 different types of components:\n\nCentral Data: Stores and share data across all the components that connect to it.\n\nData Accessors: They are the components that connect to the Central Data component. These run queries, transactions to store and retrieve data from the Database.\n\n\n  \n  UML Data Centric Software Architecture\n\n\nThe main benefits of a data centric architecture style, besides share data are:\n\n\n  Data Integrity: Data will be store with proper normalization and will be accurate.\n  Data Backup: Data containing the current state of the system can be saved to be used later.\n  Data Restoration: System state can be restored through backup.\n  Data Persistence: Data will keep alive to be used later.\n  Central Data is Passive: The main focus is storage, so the business rules stay in the application level.\n\n\nBut some disadvantages of a data centric architecture are:\n\n\n  System rely on a single data source, that, if fails, compromise all the applications.\n  Difficult to change schema, cause it is being used for many components.\n  As the data is used by many places, the overload of one application can affect all the others.\n\n\nLayered Systems\n\nIn the real world when we need to send or receive some information, we may need to talk to representatives instead of directly communicate with the final receivers. This way we guarantee the information will arrive in a standard way and we can continue focusing on our main work, emphasizing the separation of concerns.\n\n\n  \n  Layered Software Architecture\n\n\nWhen we have a layered architecture the components are only allowed to talk to adjacent components. So they do not know about upper or lower layers of the system. With this we ensure our applications will be loosely coupled and their state will not affect or be affected directly by other applications.\n\nClient Server n-tier\n\nLayered architecture is about make components loosely coupled and restricting their communication within only adjacent layers.\n\nThe n-tier or multi-tier happens when this components are also separated by being located in separate machines. So their performance, computational power consumption and environment requirements will not directly affect each other. Also other benefits like load balancing and autoscaling are benefited by a multi-tier architecture.\n\nThe relation between client and server components in a multi-tear architecture can occur in an synchronous our asynchronous way using events, web sockets and request/response handlers.\n\nAdvantages\n\n\n  Scalable: As components are distributed in different servers, it is possible to farm them and increase application capacity using techniques like load balancing and autoscaling.\n  Centralization: Centralized functionalities and computational power only to the relevant components.\n  Distribution of computational power: Only necessary application servers need to have specific hardware. It can scales horizontally if needed.\n\n\nDisadvantages\n\n\n  Ad complexity do infrastructure management.\n  Ad complexity to data synchronization.\n  Demands extra resource to manage\n\n\nInterpreter-based systems\nTBD.\nInterpreters\nState Transition Systems\n\nDataFlow Systems\nTBD.\nPipes\nFilters\n\nImplicit Invocation Systems\nTBD.\nEvent-Based\nPublish Subscribe\n\nProcess Control Systems\nTBD.\nProcess Control\n\n#\n\n",
        "url": "/software-architecture/2019/10/04/software-architectural-styles/"
      },
    
  
  
  
  {
    "title": "Categories",
    "excerpt": "Select a category\n",
    "content": "\n",
    "url": "/categories/"
  },
  
  {
    "title": "Gabriel's Blog",
    "excerpt": "…\n",
    "content": "Hello,\n\nMy name is Gabriel and I am a Software Developer based in Luxembourg. Here is a place to share my thoughts and what I have learned in my professional life.\n",
    "url": "/"
  },
  
  {
    "title": "Search",
    "excerpt": "Search for a page or post you’re looking for\n",
    "content": "{% include site-search.html %}\n",
    "url": "/search/"
  }
  
]

